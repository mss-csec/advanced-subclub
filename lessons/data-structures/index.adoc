---
liquid: true
layout: lesson
category: advanced
lesson: 7
draft: true
---
= Data Structures
:toc: macro

Data structures are methods of storing data in a way that optimizes certain important operations.

You won't get far without any of these.

[NOTE]
====
This lesson is intended mainly as a reference, and as such contain summary sections.

If you are learning these for the first time, *do not* only read the summaries, as they will be of no help.
====

toc::[]

== Sequence Containers

Sequence containers are used to store groups of similar objects in some undefined sequence, usually chronological.

=== Vector

|===
|STL analogue|link:++http://www.cplusplus.com/reference/vector/vector/++[``std::vector<T>``]
|C analogue|``T*``
|===

|===
|Random Access|Push/Pop Back|Insert/Erase|Merge
|stem:[\text{O}(1)]
|stem:[\text{O}(1)]
|stem:[\text{O}(n)]
|stem:[\text{O}(n)]
|===

Vectors are the most basic container: an array of elements.

*Accessing* an element at index stem:[i] only requires looking stem:[i] elements in memory after the first element.
Since this process is so simple, we can do this in stem:[\text{O}(1)].
This ability is called *random access*.

We can *resize* vectors by reallocating memory and copying the data over.
As this is also a simple step, this takes stem:[\text{O}(1)] time.

To **push**footnote:[insert to back] or **pop**footnote:[erase at back], we need only to resize if necessary before assigning to the last element.
This, again, takes stem:[\text{O}(1)] time.

To *insert* or *erase* at any position, however, requires that _every element after_ is shiftedfootnote:[to the right for insertions, to the left for deletions] so that there is space or the gap is filled.
Since up to all the elements might need to be shifted, and each shift must be made with a swap, this takes stem:[\text{O}(n)] time.

If we needed to *merge* two vectors and combine their data, then we would have to push up as many elements as are in both.
So, once again, this operation can occur in stem:[\text{O}(n)] time.

Vectors are your most basic container.
Most applications for storing data will use these.

=== Linked List

|===
|STL analogue|link:++http://www.cplusplus.com/reference/list/++[``std::list<T>``]footnote:[doubly-linked list]
link:++http://www.cplusplus.com/reference/forward_list/++[``std::forward_list<T>``]footnote:[singly-linked list] ^{cpp}11^
|===

|===
|Random Access|Push/Pop|Insert/Erase|Merge
|stem:[\text{O}(n)]
|stem:[\text{O}(1)]
|stem:[\text{O}(1)]
|stem:[\text{O}(1)]
|===

*Linked lists* use a very different approach from the vector.
Instead of storing every element contiguously in memory, the  location of the first element is stored and each element stores the location of the next element.

In this way, we get a "linked" list, since each element "links" to the next.

A *doubly-linked list* stores also the last element and every element also stores the location of the previous element.

We must traverse linked lists, however, element-by-element, since otherwise we don't know where anything is.
*Access*, then, is stem:[\text{O}(n)].

To *insert* or *erase* at any pointfootnote:[at where the current iterator is], we only need to manipulate a few pointers; as such, we can achieve stem:[\text{O}(1)] time.

To *push* or *pop* from the front or backfootnote:[only front in a singly-linked list], we do exactly what we did with insertion and erasure, and once again achieve stem:[\text{O}(1)] time.

And to *merge*, all we need to do is link the last element of one linked list to the first element of the other linked list -- then traversal will go through both lists.
As such, we can achieve stem:[\text{O}(1)] merging.

Now, seeing that more operations here have stem:[\text{O}(1)] time than with vectors, you may be asking, "Why not use linked lists everywhere?"

The reason why you don't see them more is because most of the time, we need to do a lot of random-access, and that wouldn't be good with an stem:[\text{O}(n)] random-access speed.

They are, however, useful where you need to combine or separate lists in different orders; for example, if you were to rotate an array by stem:[k] elements, you'd need to do stem:[n] swaps in a vector compared to a break and merge with a linked list.

=== Double-Ended Queue (Deque)
|===
|STL analogue|link:++http://www.cplusplus.com/reference/deque/++[``std::deque<T>``]
|===
|===
|Random Access|Push/Pop|Insert/Erase|Merge
|stem:[\text{O}(1)]
|stem:[\text{O}(1)]
|stem:[\text{O}(n)]
|stem:[\text{O}(n)]
|===

**D**ouble **e**nded **que**ues, or deques (pronounced like _deck_), were containers made for the purpose of quick pushing and popping from _both_ the front _and_ the back.

Typically, they take the form of a collection of vectors: pushing to the back adds to the end vector and pushing to the front adds to the begin vector.
When the end or begin vector runs out of space, a new one is declared and instantiated to have the respective position.

The collection of vectors is usually handled like both a vector _and_ a linked list; each vector links to the next and previous vectors for the sake of traversal, and a master vector of pointers to each vector is kept for the sake of random access.

As such, *access* takes two redirections, one to find where the desired vector is and one to find which element of the vector is the desired element, achieving stem:[\text{O}(1)] time.

*Pushing* and *popping* is trivial, and once again takes stem:[\text{O}(1)] time.

*Insertion* and *Erasure*, like the vector, requires the shifting of all elements, and as expected takes stem:[\text{O}(n)] time.