---
liquid: true
layout: lesson
category: advanced
lesson: 5
---
= Introduction to Algorithms

algorithm:: _n._ a process or set of rules to be followed in calculations or other problem-solving operations

'''

When we make a program, all we are doing is writing a set of instructions for computer to follow.
These instructions, of course, must be perfect -- they have to be simple enough for a computer to follow, since computers only know so much and can't interpret a programmer's intent.

With the introduction of modular programming, many oft-repeated calculations could be encapsulated into a function, and later these functions into libraries.
Standard yet complicated procedures -- like getting an integral inputfootnote:[``scanf()`` or ``std::cin``] -- could be implemented with a simple function call.

A simple program which takes two integral values and spits out its sum could be simplified to two variable decalarations, and two lines of code.
It's juat a simple *algorithm*.

Most algorithms, however, aren't so simple. In Computer Science, algorithms are about somehow manipulating memory to solve computational problems in a timely manner -- computers, after all, only know how to manipulate memory.

== Time Complexity: Measuring an Algorithm

It certainly wouldn't be a stretch to say that some algorithms are better than others.
If, for example, you had the following problem:
[quote, problem statement]
____
Given a sorted (least-to-greatest) array of size ``n``, find the index of a value ``m``.
If it does not exist, result ``-1``.
____

One way would be to iterate along the list, checking each and every element to see if it's the desired value.
This is called the *linear search*.

Another way, commonly called the *binary search*, leverages the fact that the array is sorted.
If one starts from the middle, they can easily cut the problem to half its size, as the desired value is on one side or the other and figuring out which side it's on relies on a simple comparison.

Clearly, both will work -- both algorithms will eventually find the answer.
But you can also make the observation that the binary search is _better_.
It's not because it's more sophisticated, but rather that it's faster.
If you had a 1024-element array, you can expect the following number of iterations for each algorithm:
[cols="1,2,2",options="header"]
|=======
| |Linear Search |Binary Search
|Best Case |1 iteration (once in 1024) |1 iteration (once in 1024)
|Average Case |512 iterations | 9 iterations
|Worst Case |1024 iterations (once in 1024) |10 iterations (once in 2)
|=======

So, is binary search fifty times faster than linear search?
Well, not exactly.

First of all, binary search requires more time per iteration, as it does at least one addition comparison. Secondly, binary search is less efficient over the cachefootnote:[linear search only requires switching out the cache every few (eight or so) iterations; binary search needs to switch it out almost every iteration].

But most importantly, binary search uses an entirely different approach from linear search, and it grows differently.
If you double the size of your input, linear search will take twice as many iterations on average and in the worst case.
Binary search, on the other hand, will take _one_ more iteration.

They scale differently, and when it comes to writing good algorithms, that's what matters.

Efficient scaling _really_ matters.
[quote, "CCC15S4: Convex Hull, input specifications", (emphasis added)]
____
The first line of input contains three integers K, N and M (1 &#8804; K &#8804; 200; 2 &#8804; N &#8804; *2000*; 1 &#8804; M &#8804; *10000*), each separated by one space.

The next M lines each contain 4 integers a~i~ b~i~ t~i~ h~i~ (1 &#8804; a~i~, b~i~ &#8804; N; 1 &#8804; t~i~ &#8804; *10^5^*; 0 &#8804; h~i~ &#8804; 200), each separated by one space. The i-th line in this set of M lines describes the i-th sea route (which runs from island a~i~ to island b~i~, takes t~i~ minutes and wears down the ship's hull by h~i~ centimetres). Notice that a~i~ &#8800; b~i~ (that is, the ends of a sea route are distinct islands).
____

=== Asymptotic Analysis

How do we score an algorithm quantitatively?
Obviously, we don't want to express the "time" an algorithm would take in comparison to other algorithms, because those numbers are useless.

Instead, we should try to show how it scales.
To do that, we use a technique called *asymptotic analysis*.
Formally, we do that by looking at what type of mathematical function best represents the running time of an algorithm.

Linear search takes linear time, so it scales linearly.
If you were to express this as a mathematical function, where \(T\) is time, \(n\) is the input size, and \(c\) is some proportionality coefficient, you'd have \(T=cn\).

With binary search, you may notice that it scales link:++https://en.wikipedia.org/wiki/Logarithm++[_logarithmically_].
For binary search, you'd express that with \(T=c\log{n}\).

There's a few problems with this approach, though.
That coefficient \(c\) varies from environment to environment, so it's not a very useful measure.
And the time isn't _always_ proportional to some function on the input size, as most algorithms for most problems can end earlier than the worst- or average case.

To deal with this, we developed link:++https://en.wikipedia.org/wiki/Big_O_notation++[*big-O notation*].

Formally,
[quote, Wikipedia (paraphrased), the free encyclopedia]
____
A function \(f(x)\) is \(O(g(x))\),

that is, \(f(x)=O(g(x))\text{ as }x\rightarrow\infty\) if and only if

\(pass:[|f(x)|<|Mg(x)|]\) for some constant \(M\) and for all \(x\) where \(x \gg 0\).
____

Essentially, what this means is that \(g(x)\) is the _upper bound_ of the _growth_ \(f(x)\).

Using this notation, we can say that linear search is \(O(n)\) and binary search \(O(\log{n})\) for \(n\), the size of our input array.

== Developing Algorithms



